#!/bin/bash
# Given a list of dependent files as command line arguments, this
# script creates a single source file where all the dependent files
# are declared as modules.

if [ "$#" -lt 4 ]; then
  echo "Usage: $0 output_file root_dir main_dir path1 [path2 ...]"
  echo "(All dirs and paths must be absolute.)"
  exit 1
fi

output_file=$1
root_dir=$2
main_dir=$3
shift 3

dirs=()
files_by_dir=() # $root_dir/mylib/*.ml, $root_dir/tree/tree.ml
main_files=()   # $main_dir/report1.ml
other_paths=()  # /other/path/list.ml

find_dir_index() {
  local dir_to_find="$1"
  for i in "${!dirs[@]}"; do
    if [[ "${dirs[$i]}" == "$dir_to_find" ]]; then
      echo "$i"
      return 0
    fi
  done
  echo "-1"
}

# Normalize root_dir and main_dir: ensure they end with a slash
[[ "${root_dir: -1}" != "/" ]] && root_dir="${root_dir}/"
[[ "${main_dir: -1}" != "/" ]] && main_dir="${main_dir}/"

for fullpath in "$@"; do
  relative=${fullpath#$root_dir}

  # If $relative does not start with $root_dir, it's list.ml.
  if [[ "$relative" == "$fullpath" ]]; then
    other_paths+=("$fullpath")
  # Check if file is inside main_dir using absolute path prefix
  elif [[ "$fullpath" == "$main_dir"* ]]; then
    # Strip the main_dir prefix from fullpath for filename
    filename=${fullpath#$main_dir}
    main_files+=("$filename")
  else
    if [[ "$relative" == */* ]]; then
      dir=${relative%%/*}
      file=${relative#*/}
      idx=$(find_dir_index "$dir")

      if [ "$idx" -eq -1 ]; then
        dirs+=("$dir")
        files_by_dir+=("$file")
      else
        files_by_dir[$idx]="${files_by_dir[$idx]} $file"
      fi
    else
      # File directly under root_dir but not under main_dir.  Ignore it.
      # main_files+=("$relative")
      echo "ignored: $relative"
    fi
  fi
done

#echo "Groups:"
#for i in "${!dirs[@]}"; do
#  IFS=' ' read -r -a files <<< "${files_by_dir[$i]}"
#  echo "[${dirs[$i]}] = (${files[*]})"
#done

#echo "[main files] = (${main_files[*]})"

# Capitalize the first letter of a string (compatible with Bash 3.2)
capitalize() {
  first_char=$(echo "${1:0:1}" | tr '[:lower:]' '[:upper:]')
  rest="${1:1}"
  echo "${first_char}${rest}"
}

# Example input variables:
# Replace these with your actual grouped data:
# dirs=(metro tree)
# files_by_dir=(
#   "m.ml n.ml"
#   "tree.ml"
# )
# main_files=("report1.ml" "report3.ml")
# other_paths=("/other/path/list.ml")

# Function to indent file contents
indent_contents() {
  local num_spaces=$1
  local indent=""
  local i

  for (( i=0; i<num_spaces; i++ )); do
    indent+=" "
  done

  sed "s/^/${indent}/"
}

# Start fresh output file
echo "(* This file is generated by single-source *)" > "$output_file"
echo "" >> "$output_file"

num_others=${#other_paths[@]}

for (( idx=0; idx<num_others; idx++ )); do
  other_path=${other_paths[$idx]}
  other_dir=$(dirname "$other_path")
  other_file=$(basename "$other_path")
  other_base="${other_file%.ml}"
  other_mod_file=$(capitalize "$other_base")

  echo "module $other_mod_file = struct" >> "$output_file"
  cat "$other_path" | indent_contents 2 >> "$output_file"
  echo "end" >> "$output_file"
  echo "" >> "$output_file"
done

for i in "${!dirs[@]}"; do
  dir=${dirs[$i]}
  files_str="${files_by_dir[$i]}"
  IFS=' ' read -r -a files <<< "$files_str"

  # Check for a file named like the directory (e.g., tree/tree.ml)
  main_file_match=""
  for f in "${files[@]}"; do
    base="${f%.ml}"
    if [[ "$base" == "$dir" ]]; then
      main_file_match="$f"
      break
    fi
  done

  mod_dir=$(capitalize "$dir")

  if [[ -n "$main_file_match" ]]; then
    # Output single module with contents of dir.ml
    echo "module $mod_dir = struct" >> "$output_file"
    cat "$root_dir$dir/$main_file_match" | indent_contents 2 >> "$output_file"
    echo "end" >> "$output_file"
    echo "" >> "$output_file"
  else
    # Output module with nested modules for each file
    echo "module $mod_dir = struct" >> "$output_file"
    for f in "${files[@]}"; do
      base="${f%.ml}"
      mod_file=$(capitalize "$base")
      echo "  module $mod_file = struct" >> "$output_file"
      cat "$root_dir$dir/$f" | indent_contents 4 >> "$output_file"
      echo "  end" >> "$output_file"
      echo "" >> "$output_file"
    done
    echo "end" >> "$output_file"
    echo "" >> "$output_file"
  fi
done

num_main=${#main_files[@]}

for (( idx=0; idx<num_main; idx++ )); do
  file=${main_files[$idx]}
  base="${file%.ml}"
  mod_file=$(capitalize "$base")

  if (( idx < num_main - 1 )); then
    echo "module $mod_file = struct" >> "$output_file"
    cat "$main_dir$file" | indent_contents 2 >> "$output_file"
    echo "end" >> "$output_file"
    echo "" >> "$output_file"
  else
    # Last main file output as is
    cat "$main_dir$file" >> "$output_file"
  fi
done

#echo "OCaml module aggregation complete. Output: $output_file"
